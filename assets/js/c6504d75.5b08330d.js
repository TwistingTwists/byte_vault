"use strict";(self.webpackChunkbytevault=self.webpackChunkbytevault||[]).push([[5327],{9924:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});var s=n(9205),r=n(4848),i=n(8453);const a={slug:"deep-flattening-in-rust-using-recursive-types",title:"Deep Flattening in Rust - Using Recursive Types ",date:new Date("2024-12-31T00:00:00.000Z"),authors:["joel-medicala","abeeshake"],tags:["rust"]},l=void 0,c={authorsImageUrls:[void 0,void 0]},o=[{value:"Deep Flattening in Rust: A Recursive Adventure",id:"deep-flattening-in-rust-a-recursive-adventure",level:3},{value:"The Goal",id:"the-goal",level:4},{value:"TL;DR: high level idea",id:"tldr-high-level-idea",level:3},{value:"Implementation",id:"implementation",level:3},{value:"The <code>DeepFlattenIteratorOf</code> Trait",id:"the-deepflatteniteratorof-trait",level:4},{value:"Base Case: No Nesting",id:"base-case-no-nesting",level:4},{value:"Recursive Case: Flatten Nested Items",id:"recursive-case-flatten-nested-items",level:4},{value:"Wrapper Struct for Type Inference",id:"wrapper-struct-for-type-inference",level:4},{value:"Iterator Implementation for <code>DeepFlatten</code>",id:"iterator-implementation-for-deepflatten",level:4},{value:"Example Usage",id:"example-usage",level:3}];function d(e){const t={a:"a",code:"code",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h3,{id:"deep-flattening-in-rust-a-recursive-adventure",children:"Deep Flattening in Rust: A Recursive Adventure"}),"\n",(0,r.jsxs)(t.p,{children:["Flattening nested data structures is a common problem in programming. However, flattening structures with an arbitrary depth\u2014like nested ",(0,r.jsx)(t.code,{children:"Vec"}),"s within ",(0,r.jsx)(t.code,{children:"Vec"}),"s\u2014can be tricky. Rust, with its strong type system and trait-based polymorphism, allows us to implement elegant solutions to such problems. In this post, we'll explore a recursive approach to deep flattening in Rust using traits, type inference, and iterators."]}),"\n",(0,r.jsx)(t.h4,{id:"the-goal",children:"The Goal"}),"\n",(0,r.jsx)(t.p,{children:"Given a deeply nested structure, such as:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"let nested_vec = vec![\n    vec![vec![1, 2, 3], vec![4, 5]],\n    vec![vec![6], vec![7, 8, 9]],\n];\n"})}),"\n",(0,r.jsx)(t.p,{children:"Our goal is to flatten it into:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"let flattened = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n"})}),"\n","\n",(0,r.jsxs)(t.p,{children:["The depth of nesting is not fixed\u2014it could be ",(0,r.jsx)(t.code,{children:"Vec<Vec<Vec<T>>>"}),", ",(0,r.jsx)(t.code,{children:"Vec<Vec<Vec<Vec<T>>>>"}),", or deeper."]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"tldr-high-level-idea",children:"TL;DR: high level idea"}),"\n",(0,r.jsx)(t.p,{children:"Rust\u2019s iterators and traits allow us to create a type-safe, recursive implementation to handle deep flattening. The solution uses three key components:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["**The ",(0,r.jsx)(t.strong,{children:"Trait"}),": A recursive trait defining how to flatten iterators."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Base and Recursive Implementations"}),": Separate implementations for handling the base case (non-nested items) and recursive case (nested items)."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"A Wrapper Struct"}),": A helper type to simplify type inference."]}),"\n"]}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsx)(t.p,{children:"The fun part lies in using Rust's types as in recursive way."}),"\n",(0,r.jsxs)(t.h4,{id:"the-deepflatteniteratorof-trait",children:["The ",(0,r.jsx)(t.code,{children:"DeepFlattenIteratorOf"})," Trait"]}),"\n",(0,r.jsx)(t.p,{children:"This trait defines the recursive structure of our flattening logic:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub trait DeepFlattenIteratorOf<Depth, T> {\n    type DeepFlatten: Iterator<Item = T>;\n    fn deep_flatten(this: Self) -> Self::DeepFlatten;\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Depth"})," tracks the nesting level."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"T"})," is the type of the innermost element."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"DeepFlatten"})," is the resulting iterator after flattening."]}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"base-case-no-nesting",children:"Base Case: No Nesting"}),"\n",(0,r.jsx)(t.p,{children:"The base condition stops recursion when the structure is already flat:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"impl<I: Iterator> DeepFlattenIteratorOf<(), I::Item> for I {\n    type DeepFlatten = Self;\n\n    fn deep_flatten(this: Self) -> Self::DeepFlatten {\n        this\n    }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Here, when ",(0,r.jsx)(t.code,{children:"Depth"})," is ",(0,r.jsx)(t.code,{children:"()"}),", no further flattening is needed, and the iterator is returned as-is."]}),"\n",(0,r.jsx)(t.h4,{id:"recursive-case-flatten-nested-items",children:"Recursive Case: Flatten Nested Items"}),"\n",(0,r.jsx)(t.p,{children:"For nested structures, the recursion continues until reaching the base case:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"impl<Depth, I, T> DeepFlattenIteratorOf<(Depth,), T> for I\nwhere\n    Flatten<I>: DeepFlattenIteratorOf<Depth, T>,\n    I: Iterator,\n    I::Item: IntoIterator,\n{\n    type DeepFlatten = <Flatten<I> as DeepFlattenIteratorOf<Depth, T>>::DeepFlatten;\n\n    fn deep_flatten(this: Self) -> Self::DeepFlatten {\n        DeepFlattenIteratorOf::deep_flatten(this.flatten())\n    }\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Flatten<I>"})," handles one level of flattening."]}),"\n",(0,r.jsx)(t.li,{children:"The recursion continues until it reaches the base case."}),"\n"]}),"\n",(0,r.jsx)(t.h4,{id:"wrapper-struct-for-type-inference",children:"Wrapper Struct for Type Inference"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"DeepFlatten"})," struct simplifies type inference by wrapping the recursive logic:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub struct DeepFlatten<Depth, I, T>\nwhere\n    I: DeepFlattenIteratorOf<Depth, T>,\n{\n    inner: I::DeepFlatten,\n}\n\nimpl<I: Iterator> DeepFlattenExt for I {}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This allows users to call the ",(0,r.jsx)(t.code,{children:".deep_flatten()"})," method directly:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"pub trait DeepFlattenExt: Iterator + Sized {\n    fn deep_flatten<Depth, T>(self) -> DeepFlatten<Depth, Self, T>\n    where\n        Self: DeepFlattenIteratorOf<Depth, T>,\n    {\n        DeepFlatten {\n            inner: DeepFlattenIteratorOf::deep_flatten(self),\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(t.h4,{id:"iterator-implementation-for-deepflatten",children:["Iterator Implementation for ",(0,r.jsx)(t.code,{children:"DeepFlatten"})]}),"\n",(0,r.jsx)(t.p,{children:"Finally, the iterator implementation allows seamless iteration over flattened items:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"impl<Depth, I, T> Iterator for DeepFlatten<Depth, I, T>\nwhere\n    I: DeepFlattenIteratorOf<Depth, T>,\n{\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.inner.next()\n    }\n}\n"})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.h3,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsxs)(t.p,{children:["Here\u2019s how you can use the ",(0,r.jsx)(t.code,{children:"deep_flatten"})," method to flatten nested structures:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'fn main() {\n    let nested_vec = vec![\n        vec![vec![1, 2, 3], vec![4, 5]],\n        vec![vec![6], vec![7, 8, 9]],\n    ];\n\n    let flattened: Vec<i32> = nested_vec.into_iter().deep_flatten().collect();\n\n    assert_eq!(flattened, vec![1, 2, 3, 4, 5, 6, 7, 8, 9]);\n\n    println!("Flattened result: {:?}", flattened);\n}\n'})}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsxs)(t.p,{children:["This code gist was prepared by Joel is ",(0,r.jsx)(t.a,{href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=dbd26d3c4e89abbf50cde86dec296cd7",children:"available on rust playground"}),"!"]}),"\n",(0,r.jsx)(t.p,{children:"Thanks Joel once again for bringing light to this pattern!\nThat's a wrap for this year!"}),"\n",(0,r.jsx)(t.p,{children:"See you in next year!"})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>l});var s=n(6540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},9205:e=>{e.exports=JSON.parse('{"permalink":"/byte_vault/deep-flattening-in-rust-using-recursive-types","source":"@site/blog/2024-12-31-rust-deep-flatten.mdx","title":"Deep Flattening in Rust - Using Recursive Types ","description":"Deep Flattening in Rust: A Recursive Adventure","date":"2024-12-31T00:00:00.000Z","tags":[{"inline":false,"label":"Rust","permalink":"/byte_vault/tags/rust","description":"Rust lang"}],"readingTime":3.05,"hasTruncateMarker":true,"authors":[{"name":"Joel Medicala","url":"https://github.com/JoeruCodes","page":{"permalink":"/byte_vault/authors/joel-medicala"},"socials":{"x":"https://x.com/JoeruCodes","github":"https://github.com/JoeruCodes"},"imageURL":"https://github.com/JoeruCodes.png","key":"joel-medicala"},{"name":"Abhishek Tripathi","title":"Curiosity brings awareness.","url":"https://github.com/TwistingTwists","page":{"permalink":"/byte_vault/authors/abeeshake"},"socials":{"x":"https://x.com/twistin456","github":"https://github.com/TwistingTwists"},"imageURL":"https://github.com/TwistingTwists.png","key":"abeeshake"}],"frontMatter":{"slug":"deep-flattening-in-rust-using-recursive-types","title":"Deep Flattening in Rust - Using Recursive Types ","date":"2024-12-31T00:00:00.000Z","authors":["joel-medicala","abeeshake"],"tags":["rust"]},"unlisted":false,"prevItem":{"title":"Streaming HTTP to Disk","permalink":"/byte_vault/streaming-http-to-disk"},"nextItem":{"title":"Caddy Reverse Proxy Performance: 300% Boost with Unix Sockets","permalink":"/byte_vault/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets"}}')}}]);