"use strict";(self.webpackChunkbytevault=self.webpackChunkbytevault||[]).push([[2183],{8013:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>h});var s=n(1006),r=n(4848),i=n(8453);const a={slug:"streaming-http-to-disk",title:"Streaming HTTP to Disk",date:new Date("2025-01-10T00:00:00.000Z"),authors:["abeeshake"],tags:["rust"]},o=void 0,l={authorsImageUrls:[void 0]},h=[{value:"Understanding the Streaming Process",id:"understanding-the-streaming-process",level:2},{value:"Key Points:",id:"key-points",level:3}];function d(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"theme"}),"\n",(0,r.jsx)(t.mermaid,{value:'flowchart TD\n    A["Start: Initiate Download"] --\x3e B["Send GET request using reqwest client"]\n    B --\x3e C["Receive Response object"]\n    C --\x3e D["Convert response body to byte stream using bytes_stream()"]\n    D --\x3e E["Iterate over each chunk asynchronously"]\n    E --\x3e F["Write each chunk to file using tokio::fs::File"]\n    F --\x3e G{"More chunks?"}\n    G -- Yes --\x3e E\n    G -- No --\x3e H["End: Data Saved to Disk"]\n    \n    style A fill:#f9f,stroke:#333,stroke-width:2px\n    style H fill:#bbf,stroke:#333,stroke-width:2px\n'}),"\n","\n",(0,r.jsx)(t.h2,{id:"understanding-the-streaming-process",children:"Understanding the Streaming Process"}),"\n",(0,r.jsxs)(t.p,{children:["In the provided streaming implementation, the key to avoiding loading the entire response into memory lies in ",(0,r.jsx)(t.strong,{children:"how the response body is processed"}),". Let's break down the relevant parts of the code:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'// Send the GET request and get the response\nlet resp = client\n    .get(&url)\n    .header("User-Agent", "rust-zip-extractor")\n    .send()\n    .await?\n    .error_for_status()?; // Ensure the request was successful\n\n// Convert the response body into a stream of bytes\nlet mut stream = resp.bytes_stream();\n\n// Iterate over the stream and write each chunk to the file\nwhile let Some(chunk) = stream.next().await {\n    let data = chunk?; // Handle potential stream errors\n    file.write_all(&data).await?;\n}\n'})}),"\n",(0,r.jsx)(t.h3,{id:"key-points",children:"Key Points:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:[(0,r.jsx)(t.code,{children:"send().await?"})," Does Not Buffer the Entire Response:"]})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:".send().await?"})," method initiates the HTTP request and returns a ",(0,r.jsx)(t.code,{children:"Response"})," object ",(0,r.jsx)(t.strong,{children:"without"})," reading the entire response body into memory."]}),"\n",(0,r.jsxs)(t.li,{children:["The response body is ",(0,r.jsx)(t.strong,{children:"lazy-loaded"}),", meaning it fetches data incrementally as you process the stream."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Using ",(0,r.jsx)(t.code,{children:"bytes_stream()"})," for Streaming:"]})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The ",(0,r.jsx)(t.code,{children:".bytes_stream()"})," method converts the response body into a ",(0,r.jsx)(t.code,{children:"Stream"})," of ",(0,r.jsx)(t.code,{children:"Bytes"})," chunks."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Crucially"}),", this stream processes the response incrementally, allowing you to handle large files without high memory consumption."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Writing Chunks Directly to Disk:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["By iterating over ",(0,r.jsx)(t.code,{children:"stream.next().await"}),", you handle each chunk as it arrives and immediately write it to the file."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"send().await?"})}),": Initiates the request and prepares to receive the response without buffering the entire body."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"bytes_stream()"})}),": Explicitly creates a stream that processes the response body chunk by chunk, preventing full buffering."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Therefore, ",(0,r.jsx)(t.strong,{children:"the provided code does indeed stream the response directly to disk without loading the entire response into memory"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Full code:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'use reqwest::Client;\nuse std::path::PathBuf;\nuse tokio::fs::File;\nuse tokio::io::AsyncWriteExt;\nuse uuid::Uuid;\nuse futures::StreamExt;\n\n/// Async function to download the repository as a ZIP file by streaming the response to disk.\n/// Returns the path to the saved ZIP file.\n///\n/// # Arguments\n///\n/// * `owner` - The owner of the GitHub repository.\n/// * `repo` - The name of the repository.\n/// * `reference` - The branch, tag, or commit reference.\n///\n/// # Errors\n///\n/// Returns an error if the HTTP request fails or if writing to disk fails.\npub async fn download_repo_as_zip(\n    owner: &str,\n    repo: &str,\n    reference: &str,\n) -> Result<PathBuf, Box<dyn std::error::Error>> {\n    let url = format!(\n        "https://api.github.com/repos/{owner}/{repo}/zipball/{reference}",\n        owner = owner,\n        repo = repo,\n        reference = reference\n    );\n    let client = Client::new();\n\n    // GitHub requires a User-Agent header\n    let resp = client\n        .get(&url)\n        .header("User-Agent", "rust-zip-extractor")\n        .send()\n        .await?\n        .error_for_status()?; // Ensure the request was successful\n\n    // Generate a unique filename using UUID\n    let filename = format!("{}_{}_{}.zip", owner, repo, Uuid::new_v4());\n    let filepath = PathBuf::from(&filename);\n\n    // Create the file asynchronously\n    let mut file = File::create(&filepath).await?;\n\n    // Convert the response body into a stream of bytes\n    let mut stream = resp.bytes_stream();\n\n    // Iterate over the stream and write each chunk to the file\n    while let Some(chunk) = stream.next().await {\n        let data = chunk?; // Handle potential stream errors\n        file.write_all(&data).await?;\n    }\n\n    // Ensure all data is written to disk\n    file.flush().await?;\n\n    Ok(filepath)\n}\n'})})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1006:e=>{e.exports=JSON.parse('{"permalink":"/byte_vault/blog/streaming-http-to-disk","source":"@site/blog/2025-01-10-http-streaming-to-disk.mdx","title":"Streaming HTTP to Disk","description":"theme","date":"2025-01-10T00:00:00.000Z","tags":[{"inline":false,"label":"Rust","permalink":"/byte_vault/blog/tags/rust","description":"Rust lang"}],"readingTime":2.895,"hasTruncateMarker":true,"authors":[{"name":"Abhishek Tripathi","title":"Curiosity brings awareness.","url":"https://github.com/TwistingTwists","page":{"permalink":"/byte_vault/blog/authors/abeeshake"},"socials":{"x":"https://x.com/twistin456","github":"https://github.com/TwistingTwists"},"imageURL":"https://github.com/TwistingTwists.png","key":"abeeshake"}],"frontMatter":{"slug":"streaming-http-to-disk","title":"Streaming HTTP to Disk","date":"2025-01-10T00:00:00.000Z","authors":["abeeshake"],"tags":["rust"]},"unlisted":false,"nextItem":{"title":"Understanding DDIA - Chapter 01,02","permalink":"/byte_vault/blog/ch-01-ddia"}}')}}]);