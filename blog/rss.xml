<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="rss.xsl"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Byte Vault Blog</title>
        <link>https://twistingtwists.github.io/byte_vault/blog</link>
        <description>Byte Vault Blog</description>
        <lastBuildDate>Mon, 23 Dec 2024 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[Caddy Reverse Proxy Performance: 300% Boost with Unix Sockets]]></title>
            <link>https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets</link>
            <guid>https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets</guid>
            <pubDate>Mon, 23 Dec 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[A recent GitHub issue  #6751  in the Caddy server repository revealed an interesting performance bottleneck when using multiple layers of reverse proxying. Here's what was discovered and how it was resolved.]]></description>
            <content:encoded><![CDATA[<p>A recent GitHub issue  <a href="https://github.com/caddyserver/caddy/issues/6751" target="_blank" rel="noopener noreferrer">#6751</a>  in the Caddy server repository revealed an interesting performance bottleneck when using multiple layers of reverse proxying. Here's what was discovered and how it was resolved.</p>
<!-- -->
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-problem">The Problem<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#the-problem" class="hash-link" aria-label="Direct link to The Problem" title="Direct link to The Problem">​</a></h2>
<p>A user reported significant performance degradation when implementing multiple layers of reverse proxies in Caddy v2.8.4. The setup consisted of a chain of reverse proxies:</p>
<ul>
<li>Port 8081: Serving static files</li>
<li>Port 8082: Proxying to 8081</li>
<li>Port 8083: Proxying to 8082</li>
<li>Port 8084: Proxying to 8083</li>
</ul>
<p>When testing with a 1000MB file download, the performance metrics showed a clear pattern of degradation:</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="multi-threading-performance-impact">Multi-Threading Performance Impact<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#multi-threading-performance-impact" class="hash-link" aria-label="Direct link to Multi-Threading Performance Impact" title="Direct link to Multi-Threading Performance Impact">​</a></h3>
<ul>
<li>Direct file server (8081): ~300 Mbps with 5 threads</li>
<li>First proxy layer (8082): ~60 Mbps with 5 threads</li>
<li>Second proxy layer (8083): ~16 Mbps with 5 threads</li>
<li>Third proxy layer (8084): ~16 Mbps with 5 threads</li>
</ul>
<p>What made this particularly interesting was that the server's CPU usage remained surprisingly low (1-5%), suggesting that the bottleneck wasn't in processing power.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-investigation">The Investigation<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#the-investigation" class="hash-link" aria-label="Direct link to The Investigation" title="Direct link to The Investigation">​</a></h2>
<p>The investigation, led by Caddy maintainers including Matt Holt, involved:</p>
<ol>
<li>Gathering system metrics</li>
<li>Analyzing CPU and memory profiles</li>
<li>Testing different network configurations</li>
<li>Examining kernel settings</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="table-1-system-metrics">Table 1: System Metrics<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#table-1-system-metrics" class="hash-link" aria-label="Direct link to Table 1: System Metrics" title="Direct link to Table 1: System Metrics">​</a></h3>
<table><thead><tr><th><strong>Commands</strong></th><th><strong>Why It Is Relevant to Debugging</strong></th><th><strong>Output and Conclusion</strong></th></tr></thead><tbody><tr><td><code>ulimit -a</code></td><td>Checks system limits such as maximum number of open files and other resource constraints that could impact performance.</td><td>No bottlenecks identified in file descriptors or resource limits.</td></tr><tr><td><code>sysctl -p</code></td><td>Confirms network-related kernel parameters such as buffer sizes, default queuing discipline, and TCP congestion control settings.</td><td><br><code>net.core.rmem_max = 2097152</code><br><code>net.core.wmem_max = 2097152</code><br><code>net.core.default_qdisc = fq</code><br><code>net.ipv4.tcp_congestion_control = bbr</code><br><br> Settings were optimized for high-speed networking.<br>TCP congestion control was correctly set to<code>bbr</code>.</td></tr><tr><td>General hardware specs (CPU, RAM, NIC, etc.)</td><td>baseline hardware information</td><td>Verified adequate resources (1 Core Ryzen 5950X, 1024MB RAM, 10Gbps NIC). No resource-related constraints.</td></tr></tbody></table>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="table-2-profile-analysis">Table 2: Profile Analysis<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#table-2-profile-analysis" class="hash-link" aria-label="Direct link to Table 2: Profile Analysis" title="Direct link to Table 2: Profile Analysis">​</a></h3>
<table><thead><tr><th><strong>Commands</strong></th><th><strong>Why It Is Relevant to Debugging</strong></th><th><strong>Output and Conclusion</strong></th></tr></thead><tbody><tr><td>Attempted to collect goroutine profiles</td><td>Helps identify bottlenecks or inefficiencies in goroutines that may be causing performance issues.</td><td>Could not identify significant bottlenecks in goroutines.</td></tr><tr><td>Accessed CPU Profile via browser</td><td>Provides CPU usage details to determine if high CPU usage is a factor affecting performance.</td><td>No high CPU usage detected. CPU load was between 1-5%.</td></tr><tr><td><code>wget http://127.0.0.1:2019/debug/pprof/profile?seconds=1000</code></td><td>Downloads detailed CPU profiles for offline analysis.</td><td>Profiles downloaded successfully. Further analysis confirmed no CPU bottlenecks or inefficiencies.</td></tr><tr><td>Collected heap profiles</td><td>Helps analyze memory usage and potential leaks in the application.</td><td>Memory usage was within acceptable limits, with no indication of memory leaks.</td></tr></tbody></table>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="table-3-network-testing">Table 3: Network Testing<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#table-3-network-testing" class="hash-link" aria-label="Direct link to Table 3: Network Testing" title="Direct link to Table 3: Network Testing">​</a></h3>
<table><thead><tr><th><strong>Commands</strong></th><th><strong>Why It Is Relevant to Debugging</strong></th><th><strong>Output and Conclusion</strong></th></tr></thead><tbody><tr><td>Tests from multiple locations (Singapore, Los Angeles, Seoul)</td><td>Evaluates network performance across different regions to identify geographical bottlenecks.</td><td>Performance was consistent across all regions.</td></tr><tr><td>Tests with different file sizes (100MiB, 1000MiB)</td><td>Determines if performance issues are related to file size or payload.</td><td>No significant performance variance with different file sizes.</td></tr><tr><td><code>curl -o /dev/null http://host.domain:port/1000MiB</code></td><td>Single-threaded test evaluates download performance under minimal concurrency.</td><td>acceptable network speed</td></tr><tr><td><code>echo 1 1 1 1 1 | xargs -n1 -P5 curl -s -o /dev/null http://host.domain:port/1000MiB</code></td><td></td><td>Multi-threaded test assesses network performance under concurrent load.</td></tr></tbody></table>
<hr>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="table-4-kernel-analysis">Table 4: Kernel Analysis<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#table-4-kernel-analysis" class="hash-link" aria-label="Direct link to Table 4: Kernel Analysis" title="Direct link to Table 4: Kernel Analysis">​</a></h3>
<table><thead><tr><th><strong>Commands</strong></th><th><strong>Why It Is Relevant to Debugging</strong></th><th><strong>Output and Conclusion</strong></th></tr></thead><tbody><tr><td>Checked systemd service file settings</td><td>Confirms that the maximum number of open files is sufficient for high-concurrency workloads.</td><td>Verified<code>LimitNOFILE=1048576</code>. No issues found.</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-solution">The Solution<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#the-solution" class="hash-link" aria-label="Direct link to The Solution" title="Direct link to The Solution">​</a></h2>
<p>The breakthrough came when testing with Unix sockets instead of TCP connections. By modifying the Caddyfile to use Unix sockets for inter-process communication, the performance issues were completely resolved. Here's what the optimized configuration looked like:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">:8081 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bind 0.0.0.0 unix//dev/shm/8081.sock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    file_server browse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    root * /opt/www</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">:8082 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bind 0.0.0.0 unix//dev/shm/8082.sock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reverse_proxy unix//dev/shm/8081.sock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">:8083 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bind 0.0.0.0 unix//dev/shm/8083.sock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reverse_proxy unix//dev/shm/8082.sock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">:8084 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reverse_proxy unix//dev/shm/8083.sock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="key-takeaways">Key Takeaways<a href="https://twistingtwists.github.io/byte_vault/blog/how-to-solve-reverse-proxy-performance-issues-in-caddy-server-a-300-performance-boost-using-unix-sockets#key-takeaways" class="hash-link" aria-label="Direct link to Key Takeaways" title="Direct link to Key Takeaways">​</a></h2>
<ol>
<li>TCP connection overhead can significantly impact performance in multi-layer reverse proxy setups</li>
<li>Unix sockets provide a more efficient alternative for local inter-process communication</li>
<li>Low CPU usage doesn't always mean optimal performance - network stack overhead can be the bottleneck</li>
<li>When dealing with multiple local reverse proxies, consider using Unix sockets instead of TCP connections</li>
</ol>]]></content:encoded>
            <category>Performance</category>
            <category>Caddy</category>
        </item>
        <item>
            <title><![CDATA[1brc - same tricks across languages]]></title>
            <link>https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages</link>
            <guid>https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages</guid>
            <pubDate>Sun, 22 Dec 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[The 1 Billion Row Challenge (1BRC) is a programming challenge focused on processing a large dataset of temperature measurements. If you're unfamiliar with it, you can learn more from these resources: 1 and 2.]]></description>
            <content:encoded><![CDATA[<p>The 1 Billion Row Challenge (1BRC) is a programming challenge focused on processing a large dataset of temperature measurements. If you're unfamiliar with it, you can learn more from these resources: <a href="https://github.com/gunnarmorling/1brc" target="_blank" rel="noopener noreferrer">1</a> and <a href="https://www.morling.dev/blog/1brc-results-are-in/" target="_blank" rel="noopener noreferrer">2</a>.</p>
<p>This is a cheatsheet  of optimisations done for 1brc challenges. It tries to summarise and put the optimisations in perspective.</p>
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-encoding--parsing">Data encoding / parsing<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#data-encoding--parsing" class="hash-link" aria-label="Direct link to Data encoding / parsing" title="Direct link to Data encoding / parsing">​</a></h3>
<table><thead><tr><th style="text-align:left">Trick</th><th>Outcome</th><th>Note</th></tr></thead><tbody><tr><td style="text-align:left">converting contents of file as string: don't!</td><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#discussioncomment-8153186" target="_blank" rel="noopener noreferrer">~10% perf</a></td><td>Don't convert the contents of the file to<code>String</code>. Simply process raw bytes.</td></tr><tr><td style="text-align:left">parsing float values<br></td><td></td><td>parsing after assuming only one place after decimal.</td></tr><tr><td style="text-align:left">parsing integer</td><td></td><td><a href="https://youtu.be/EFXxXFHpS0M?t=1255" target="_blank" rel="noopener noreferrer">Branchless Programming via Bit Manipulation</a><br> this is not generalizable</td></tr><tr><td style="text-align:left">parsing the city name (finding<code>;</code> separator)</td><td></td><td>If the data looks like<code>Tokio;13.4</code> and we want to find <code>;</code><br><br>using 8 operations, you can find <code>;</code>.<br><br><br>SWAR = SIMD as a register</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reading-files-from-disk">Reading files from disk<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#reading-files-from-disk" class="hash-link" aria-label="Direct link to Reading files from disk" title="Direct link to Reading files from disk">​</a></h3>
<table><thead><tr><th>Trick</th><th>Outcome</th><th>Note</th></tr></thead><tbody><tr><td>Reading in chunks<a href="https://www.bytesizego.com/blog/one-billion-row-challenge-go#:~:text=Reading%20file%3A%20Read%20in%20chunks" target="_blank" rel="noopener noreferrer">golang</a></td><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#discussioncomment-8153186" target="_blank" rel="noopener noreferrer">~10% perf</a></td><td></td></tr><tr><td>mmap</td><td></td><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#discussioncomment-8041416" target="_blank" rel="noopener noreferrer">mmap the input file. Split input based on core count and run it with a thread per core.</a><br><br>mmap is an unsafe operation in Rust.</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="float-handling">Float handling<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#float-handling" class="hash-link" aria-label="Direct link to Float handling" title="Direct link to Float handling">​</a></h3>
<table><thead><tr><th>Trick</th><th>Outcome</th><th>Notes</th></tr></thead><tbody><tr><td>Don't do floating point operations. Use int.</td><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#discussioncomment-8024568" target="_blank" rel="noopener noreferrer">20% speed gains</a></td><td></td></tr><tr><td>Use fixed size integers instead of float</td><td><a href="https://benhoyt.com/writings/go-1brc/#:~:text=Solution%204%3A%20fixed%20point%20integers" target="_blank" rel="noopener noreferrer">~10% gain in golang</a></td><td></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-hashmap---simpler-hash-function">The Hashmap - simpler hash function<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#the-hashmap---simpler-hash-function" class="hash-link" aria-label="Direct link to The Hashmap - simpler hash function" title="Direct link to The Hashmap - simpler hash function">​</a></h3>
<table><thead><tr><th>Trick</th><th>Outcome</th><th>Note</th></tr></thead><tbody><tr><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#:~:text=Treat%20the%20first%20eight%20bytes%20of%20the%20name%20as%20a%20hash%20key%20into%20a%20fixed%20size%2010k%20item%20hash%20table." target="_blank" rel="noopener noreferrer">Fixed Size hash table 10k</a></td><td><a href="https://benhoyt.com/writings/go-1brc/#:~:text=the%20custom%20hash%20table%20cuts%20down%20the%20time%20from%2041.3%20seconds%20to%2022.1s." target="_blank" rel="noopener noreferrer">~40% gain - the custom hash table cuts down the time from 41.3 seconds to 22.1s.</a></td><td>How to resolve collisions?<br><br>- Find first unoccupied slot<br>- <br><a href="https://benhoyt.com/writings/go-****1brc/#:~:text=It%E2%80%99s%20a%20simple%20implementation%20that%20uses%20the%20FNV%2D1a%20hash%20algorithm%20with%20linear%20probing%3A%20if%20there%E2%80%99s%20a%20collision%2C%20use%20the%20next%20empty%20slot." target="_blank" rel="noopener noreferrer">if hash collide, goto next empty slot algorithm</a></td></tr><tr><td>Hash key - Integer, not String</td><td><a href="https://youtu.be/SVw9nKfVPx4?t=501" target="_blank" rel="noopener noreferrer">4x gain in a different competition</a></td><td>the time is spent in<code>Hashmap.get</code>.<br> Not in 1brc, but in <a href="https://www.youtube.com/watch?v=SVw9nKfVPx4&amp;t=501s" target="_blank" rel="noopener noreferrer">other context</a>, Hashmap.get was the bottleneck. hence this optimisation makes a lot of difference there, not in 1brc.</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="with-os-threads-and-parallelism---go-brr">With OS threads and parallelism - go brr!<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#with-os-threads-and-parallelism---go-brr" class="hash-link" aria-label="Direct link to With OS threads and parallelism - go brr!" title="Direct link to With OS threads and parallelism - go brr!">​</a></h3>
<table><thead><tr><th>Trick</th><th>Outcome</th><th>Notes</th></tr></thead><tbody><tr><td>address the go routine + rust tokio task + erlang processes?</td><td><a href="https://benhoyt.com/writings/go-1brc/#:~:text=Processing%20the%20input%20file%20in%20parallel%20provides%20a%20huge%20win%20over%20r1%2C%20taking%20the%20time%20from%201%20minute%2045%20seconds%20to%2022.6%20seconds." target="_blank" rel="noopener noreferrer">~ 4-6x gains</a></td><td>biggest gains are obtained by utilizing OS threads fully!</td></tr></tbody></table>]]></content:encoded>
            <category>Performance</category>
        </item>
    </channel>
</rss>