<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://twistingtwists.github.io/byte_vault/blog</id>
    <title>Byte Vault Blog</title>
    <updated>2024-10-25T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://twistingtwists.github.io/byte_vault/blog"/>
    <subtitle>Byte Vault Blog</subtitle>
    <icon>https://twistingtwists.github.io/byte_vault/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[1brc - same tricks across languages]]></title>
        <id>https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages</id>
        <link href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages"/>
        <updated>2024-10-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The 1 Billion Row Challenge (1BRC) is a programming challenge focused on processing a large dataset of temperature measurements. If you're unfamiliar with it, you can learn more from these resources: 1 and 2.]]></summary>
        <content type="html"><![CDATA[<p>The 1 Billion Row Challenge (1BRC) is a programming challenge focused on processing a large dataset of temperature measurements. If you're unfamiliar with it, you can learn more from these resources: <a href="https://github.com/gunnarmorling/1brc" target="_blank" rel="noopener noreferrer">1</a> and <a href="https://www.morling.dev/blog/1brc-results-are-in/" target="_blank" rel="noopener noreferrer">2</a>.</p>
<p>This is a cheatsheet  of optimisations done for 1brc challenges. It tries to summarise and put the optimisations in perspective.</p>
<!-- -->
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="data-encoding--parsing">Data encoding / parsing<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#data-encoding--parsing" class="hash-link" aria-label="Direct link to Data encoding / parsing" title="Direct link to Data encoding / parsing">​</a></h3>
<table><thead><tr><th style="text-align:left">Trick</th><th>Outcome</th><th>Note</th></tr></thead><tbody><tr><td style="text-align:left">converting contents of file as string: don't!</td><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#discussioncomment-8153186" target="_blank" rel="noopener noreferrer">~10% perf</a></td><td>Don't convert the contents of the file to<code>String</code>. Simply process raw bytes.</td></tr><tr><td style="text-align:left">parsing float values<br></td><td></td><td>parsing after assuming only one place after decimal.</td></tr><tr><td style="text-align:left">parsing integer</td><td></td><td><a href="https://youtu.be/EFXxXFHpS0M?t=1255" target="_blank" rel="noopener noreferrer">Branchless Programming via Bit Manipulation</a><br> this is not generalizable</td></tr><tr><td style="text-align:left">parsing the city name (finding<code>;</code> separator)</td><td></td><td>If the data looks like<code>Tokio;13.4</code> and we want to find <code>;</code><br><br>using 8 operations, you can find <code>;</code>.<br><br><br>SWAR = SIMD as a register</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="reading-files-from-disk">Reading files from disk<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#reading-files-from-disk" class="hash-link" aria-label="Direct link to Reading files from disk" title="Direct link to Reading files from disk">​</a></h3>
<table><thead><tr><th>Trick</th><th>Outcome</th><th>Note</th></tr></thead><tbody><tr><td>Reading in chunks<a href="https://www.bytesizego.com/blog/one-billion-row-challenge-go#:~:text=Reading%20file%3A%20Read%20in%20chunks" target="_blank" rel="noopener noreferrer">golang</a></td><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#discussioncomment-8153186" target="_blank" rel="noopener noreferrer">~10% perf</a></td><td></td></tr><tr><td>mmap</td><td></td><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#discussioncomment-8041416" target="_blank" rel="noopener noreferrer">mmap the input file. Split input based on core count and run it with a thread per core.</a><br><br>mmap is an unsafe operation in Rust.</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="float-handling">Float handling<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#float-handling" class="hash-link" aria-label="Direct link to Float handling" title="Direct link to Float handling">​</a></h3>
<table><thead><tr><th>Trick</th><th>Outcome</th><th>Notes</th></tr></thead><tbody><tr><td>Don't do floating point operations. Use int.</td><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#discussioncomment-8024568" target="_blank" rel="noopener noreferrer">20% speed gains</a></td><td></td></tr><tr><td>Use fixed size integers instead of float</td><td><a href="https://benhoyt.com/writings/go-1brc/#:~:text=Solution%204%3A%20fixed%20point%20integers" target="_blank" rel="noopener noreferrer">~10% gain in golang</a></td><td></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-hashmap---simpler-hash-function">The Hashmap - simpler hash function<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#the-hashmap---simpler-hash-function" class="hash-link" aria-label="Direct link to The Hashmap - simpler hash function" title="Direct link to The Hashmap - simpler hash function">​</a></h3>
<table><thead><tr><th>Trick</th><th>Outcome</th><th>Note</th></tr></thead><tbody><tr><td><a href="https://github.com/gunnarmorling/1brc/discussions/57#:~:text=Treat%20the%20first%20eight%20bytes%20of%20the%20name%20as%20a%20hash%20key%20into%20a%20fixed%20size%2010k%20item%20hash%20table." target="_blank" rel="noopener noreferrer">Fixed Size hash table 10k</a></td><td><a href="https://benhoyt.com/writings/go-1brc/#:~:text=the%20custom%20hash%20table%20cuts%20down%20the%20time%20from%2041.3%20seconds%20to%2022.1s." target="_blank" rel="noopener noreferrer">~40% gain - the custom hash table cuts down the time from 41.3 seconds to 22.1s.</a></td><td></td></tr><tr><td>How to resolve collisions?<br><br>- Find first unoccupied slot<br>- <br><a href="https://benhoyt.com/writings/go-1brc/#:~:text=It%E2%80%99s%20a%20simple%20implementation%20that%20uses%20the%20FNV%2D1a%20hash%20algorithm%20with%20linear%20probing%3A%20if%20there%E2%80%99s%20a%20collision%2C%20use%20the%20next%20empty%20slot." target="_blank" rel="noopener noreferrer">if hash collide, goto next empty slot algorithm</a></td><td></td><td></td></tr><tr><td></td><td>Hash key - Integer, not String</td><td><a href="https://youtu.be/SVw9nKfVPx4?t=501" target="_blank" rel="noopener noreferrer">4x gain in a different competition</a></td></tr><tr><td>the time is spent in<code>Hashmap.get</code>.<br> Not in 1brc, but in <a href="https://www.youtube.com/watch?v=SVw9nKfVPx4&amp;t=501s" target="_blank" rel="noopener noreferrer">other context</a>, Hashmap.get was</td><td></td><td></td></tr><tr><td>the bottleneck. hence this optimisation makes a lot of difference there, not in</td><td></td><td></td></tr><tr><td>1brc.</td><td></td><td></td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="with-os-threads-and-parallelism---go-brr">With OS threads and parallelism - go brr!<a href="https://twistingtwists.github.io/byte_vault/blog/1brc-same-tricks-across-languages#with-os-threads-and-parallelism---go-brr" class="hash-link" aria-label="Direct link to With OS threads and parallelism - go brr!" title="Direct link to With OS threads and parallelism - go brr!">​</a></h3>
<table><thead><tr><th>Trick</th><th>Outcome</th><th>Notes</th></tr></thead><tbody><tr><td>address the go routine + rust tokio task + erlang processes?</td><td><a href="https://benhoyt.com/writings/go-1brc/#:~:text=Processing%20the%20input%20file%20in%20parallel%20provides%20a%20huge%20win%20over%20r1%2C%20taking%20the%20time%20from%201%20minute%2045%20seconds%20to%2022.6%20seconds." target="_blank" rel="noopener noreferrer">~ 4-6x gains</a></td><td>biggest gains are obtained by utilizing OS threads fully!</td></tr></tbody></table>]]></content>
        <author>
            <name>Abhishek Tripathi</name>
            <uri>https://github.com/TwistingTwists</uri>
        </author>
        <category label="Performance" term="Performance"/>
    </entry>
</feed>